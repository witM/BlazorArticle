@inherits PageBase
@layout BlazorArticleWebClient.Layout.ArticleLayout

@page "/postview/"
@page "/postview/{ArticleName}"

@using BlazorArticle.Components
@using BlazorArticleWebClient.Services
@using Microsoft.AspNetCore.Components.Sections

@*To see better prerendered results (in site source) in static side rendering set this to "false" - you don't see loading indicator without InteractiveServer rendering mode
  Starting with .NET 10, the Persistent State mechanism will be more accessible and easier to use.
*@
@attribute [StreamRendering(false)] 

@implements IDisposable

@inject NavigationManager Navigation
@inject IHttpClientFactory ClientFactory
@inject IOptions<AppConfig> Config


<PageTitle>
    @if(Layout.IsArticleLoaded)
    {
        @("article loaded")
    }
</PageTitle>

@if(!Layout.IsArticleLoaded)
{
    <div class="d-flex flex-column justify-content-center align-items-center" style="height:100%">
        <img src="/img/spin_loading.gif" alt="loading article" />
    </div>
}
else
{
    @*Renders css style in the head - In Blazor WebAssembly use "UseJavascript" parameter is optional *@
   <ArticleStyleContent Style="@_articleData.ContentStyle"  UseJavascript="false" IsCompressed="false"/>


   @*
       @key is needed for two reasons:
       1)there are some javascript DOM interlop after article has been rendered at server side
       2)there are (maybe) rendering different types of render fragments in the loop by "ArticleRenderer" component
   *@
    <div class="page" @key="@_articleData.Id">
        <article>
            @*This component renders article exactly at place where it is with support of BlazorArticle parsing system,
             *if you don't need this you can just use markupstring: @((MarkupString)string)
            *@
            <ArticleRenderer Content="@_articleData.Content" RemoveComments="false"  /> 
        </article>
    </div>

}

 <SectionContent SectionName="sidebar-article">
    @if(Layout.IsArticleLoaded)
    {
         <!-- sticky header is hardcoded as 50px height -->
        <div class="sticky-top" style="top:50px;">
         
            <TableOfContent @ref="Ref_TOC" />
        </div>
        

    }
</SectionContent> 




@code {

    class ArticleData
    {
        public string Id{ get; set; }
        public string Content{ get; set; }
        public string ContentStyle{ get; set; }
    }

    [CascadingParameter]
    public ArticleLayout Layout{ get; set; }

    [Parameter]
    public string? ArticleName { get; set; } 

    [SupplyParameterFromQuery(Name = "style")]
    private string? StyleName{ get; set; }

    TableOfContent Ref_TOC{ get; set; }

    ArticleData _articleData;


    protected override async Task OnInitializedAsync()
    {
        Layout.RefreshAllRequested += OnRefreshAll;
        Layout.RefreshStyle += OnRefreshStyle;


    }

    protected override async Task OnParametersSetAsync()
    {
        // if is not set in url then use this by default
        ArticleName ??= "quadratic_equation";
        StyleName ??= "math";
        //////////////

        if(!Layout.IsArticleLoaded)
        {
            _articleData = new ArticleData();
            _articleData.Id = Guid.NewGuid().ToString();
            _articleData.Content = await GetArticleContentAsync(ArticleName);
            _articleData.ContentStyle = await GetArticleStyleContentAsync(StyleName);
            Layout.IsArticleLoaded = true;
        }

    }


    async Task OnRefreshAll()
    {
        //WARNING:The order of assignment is important if you  make new ArticleData because it may cause rerendering compoent <ArticleRenderer> with null content.
        //Make sure you first create new temp instance and then assign _articleData = temp;
        ///
        // WARNING: The Content parameter of <ArticleRenderer> changes after 'await',
        // so assigning _articleContent like shown below ensures the component rerenders only once and correctly.
        var data = new ArticleData();
        data.Id = Guid.NewGuid().ToString();
        data.Content =  await GetArticleContentAsync(ArticleName);
        data.ContentStyle = await GetArticleStyleContentAsync(StyleName);
        _articleData = data;
        await InvokeAsync(StateHasChanged);
        Ref_TOC.Refresh();
    }

    async Task OnRefreshStyle(string styleName)
    {
        _articleData.ContentStyle = await GetArticleStyleContentAsync(styleName);
        StateHasChanged();
    }


    public void Dispose()
    {
        Layout.RefreshAllRequested -= OnRefreshAll;
        Layout.RefreshStyle -= OnRefreshStyle;

    }


    async Task<string?> GetArticleContentAsync(string articleName)
    {
        string ArticlesBasePath = Config.Value.SourceArticle;
        string siteBaseUrl = Navigation.BaseUri;


        using (var client = ClientFactory.CreateClient("default"))
        {
            string url = $"{siteBaseUrl}{ArticlesBasePath}/{articleName}.html";

            return  await client.GetStringAsync(url);

        }

    }


    async Task<string?> GetArticleStyleContentAsync(string styleName)
    {
        string ArticlesStyleBasePath = Config.Value.SourceArticleStyle;
        string siteBaseUrl = Navigation.BaseUri;

        using (var client = ClientFactory.CreateClient("default"))
        {
            string url = $"{siteBaseUrl}{ArticlesStyleBasePath}/{styleName}.css";

            return await client.GetStringAsync(url);

        }
    }

}
